! The following four operations, "read_by_name",  "write_by_name",
! "read_and_add", and "quad_var" are designed to read/write a record
! "rec" of a variable, and, the last two, perform an simple operation
! with the buffer just read. The variable may be a spatial scalar (with
! or without time dimension), a 2D- or 3D-field.  All dimensions of the
! variable are determined automatically from the netCDF file, and the
! time dimension is identified by having ints name end with "....time".
! If the variable does not have time dimension, the argument "rec" is
! ignored.  Note that despite formally declaring the variable to be
! read/written as real*4, the code is designed in such a way that it is
! actually typeless: in the case of "read_"- and "write_by_name" the
! argument "var" can be of any legal netCDF type (no type conversions
! are performed here), while "read_and_add" and "quad_var" can accept
! their arguments "var", "buff", and "average" as either single- or
! double-precision floating point.  However, in any case it is user
! responsibility to make sure that arrays in the calling program are
! of the same time as in the netCDF file.

! Because of bulk of the code is the same among the four routines,
! they are generated by CPP self-expansion.

#ifdef READ
# ifdef READ_AND_ADD
#  ifdef QUAD_VARIANCE
      subroutine quad_var (ncid, vname, rec, var, buff, average)
#  else
      subroutine read_and_add  (ncid, vname, rec, var,  buff)
#  endif
# else
      subroutine read_by_name  (ncid, vname, rec, var)
# endif
#else
      subroutine write_by_name (ncid, vname, rec, var)
#endif
      use mod_io_size_acct
      implicit none
      character(len=*) vname
      character(len=32) name
      integer ncid, rec, indx, varid, vtype, ndims, dimid(8), natts,
     &        ierr, size,  start(8),  count(8), i, lvar, lnm, lenstr
      real(kind=4), dimension(*) :: var
#ifdef READ_AND_ADD
     &                             , buff
# ifdef QUAD_VARIANCE
     &                             , average
# endif
#endif
#include "netcdf.inc"

      lvar=lenstr(vname)     ! Reset everything. Note that "indx"
      do i=1,8               ! is merely a flag to signal that the
        start(i)=0           ! variable has, or does not have time
        count(i)=0           ! dimension: if it has, "indx" will be
        dimid(i)=0           ! overwritten by "rec"; for a timeless
      enddo                  ! variable it stays 0.
      indx=0

      ierr=nf_inq_varid (ncid, vname, varid)
      if (ierr==nf_noerr) then
        ierr=nf_inq_var (ncid, varid, name,  vtype,
     &                         ndims, dimid, natts)
        if (ierr == nf_noerr) then
          do i=1,ndims
            ierr=nf_inq_dim (ncid, dimid(i), name, size)
            if (ierr == nf_noerr) then
              lnm=lenstr(name)
              start(i)=1
              count(i)=size
              if (i == ndims  .and. lnm > 3) then
                if (name(lnm-3:lnm) == 'time') then
                  start(i)=rec
                  count(i)=1
                  indx=rec
c**               write(*,*) 'identified ''',name(1:lnm),'''.',rec
                endif
              endif
            else
              write(*,'(/1x,3A,I3,A/12x,A/)') '### ERROR: Cannot ',
     &                'determine name and size of dimension with ',
     &                'ID =',  dimid(i),  ':',  nf_strerror(ierr)
              stop
            endif
          enddo                    ! READ_AND_ADD always needs
          size=1                   ! "size" to compute the result;
          do i=1,ndims             ! all others also need it to
            size=size*count(i)     ! count aggregate data read or
          enddo                    ! written.

c**       write(*,'(/1x,3A,I3,2x,A,I3)') 'vname = ''', vname(1:lvar),
c**  &                       ''' varid =', varid,  'ndims =', ndims
c**       write(*,'(20x,A,4I4)')    'start =', (start(i), i=1,ndims)
c**       write(*,'(20x,A,4I4)')    'count =', (count(i), i=1,ndims)


#ifdef READ
# ifdef VBUFF
#  undef VBUFF
# endif
# ifdef READ_AND_ADD
#  define VBUFF buff
# else
#  define VBUFF var
# endif


          if (vtype == nf_real) then
            ierr=nf_get_vara_real(ncid, varid, start,count, VBUFF)
            sz_read_acc=sz_read_acc + 4*size
          elseif (vtype == nf_double) then
            ierr=nf_get_vara_double(ncid, varid, start,count, VBUFF)
            sz_read_acc=sz_read_acc + 8*size
# ifndef READ_AND_ADD
          elseif (vtype == nf_int) then
            ierr=nf_get_vara_int  (ncid, varid, start,count, VBUFF)
            sz_read_acc=sz_read_acc + 4*size
          elseif (vtype == nf_char) then
            ierr=nf_get_vara_text (ncid, varid, start,count, VBUFF)
            sz_read_acc=sz_read_acc + size
# endif

# undef VBUFF
          else
            write(*,'(/1x,3A/)')   '### ERROR: netCDF variable ''',
     &          vname(1:lvar), ''' is of unknown or illegal type.'
            stop
          endif

          if (ierr == nf_noerr) then
            write(*,'(6x,A,I5,1x,3A)')  'read rec', indx, 'of ''',
     &                                       vname(1:lvar), '''.'
          else
            write(*,'(/1x,4A/12x,A)')    '### ERROR: Cannot read ',
     &              'netCDF variable ''',    vname(1:lvar),  ''':',
     &                                           nf_strerror(ierr)
            write(*,'(12x,A,4I5)') 'start =', (start(i),i=1,ndims)
            write(*,'(12x,A,4I5)') 'count =', (count(i),i=1,ndims)
            stop
          endif
# ifdef READ_AND_ADD
#  ifdef QUAD_VARIANCE
CXXX          if (vtype == nf_real) then
            call add_quad_var_real (var, buff, average, size)
CXXX          elseif (vtype == nf_double) then
CXXX            call add_quad_var_double (var, buff, average, size)
CXXX          endif
#  else
CXXX          if (vtype == nf_real) then
            call add_buff_to_var_real (var, buff, size)
CXXX          elseif (vtype == nf_double) then
CXXX            call add_buff_to_var_double (var, buff, size)
CXXX          endif
#  endif
# endif
#else
          if (vtype == nf_real) then
            ierr=nf_put_vara_real (ncid, varid, start,count, var)
            sz_write_acc=sz_write_acc + 4*size
          elseif (vtype == nf_double) then
            ierr=nf_put_vara_double(ncid, varid, start,count, var)
            sz_write_acc=sz_write_acc + 8*size
          elseif (vtype == nf_int) then
            ierr=nf_put_vara_int   (ncid, varid, start,count, var)
            sz_write_acc=sz_write_acc + 4*size
          elseif (vtype == nf_char) then
            ierr=nf_put_vara_text  (ncid, varid, start,count, var)
            sz_write_acc=sz_write_acc + size
          else
            write(*,'(/1x,3A/)')   '### ERROR: variable ''',
     &              vname(1:lvar), ''' is of unknown type.'
            stop
          endif
          if (ierr == nf_noerr) then
            write(*,'(5x,A,I5,1x,3A)')  'wrote rec', indx, 'of ''',
     &                                         vname(1:lvar), ''''
          else
            write(*,'(/1x,4A/12x,A/)')  '### ERROR: Cannot write ',
     &                         'netCDF variable ''', vname(1:lvar),
     &                                   ''':',  nf_strerror(ierr)
          endif
#endif
        else
          write(*,'(/1x,2A,I3,2x,3A/12x,A/)')   '### ERROR: Cannot ',
     &      'make general inquiry for variable #', varid, 'named ''',
     &                       vname(1:lvar), ''':', nf_strerror(ierr)
        endif
      else
        write(*,'(/1x,4A/12x,A/)')   '### ERROR: Cannot get netCDF ',
     &                         'ID for variable ''', vname(1:lvar),
     &                                      ''':', nf_strerror(ierr)
      endif
      if (ierr/=nf_noerr) stop
      return
      end

#ifdef READ_AND_ADD
# ifdef QUAD_VARIANCE
       subroutine add_quad_var_real (var, buff, average, size)
       implicit none
       integer size, i
       real(kind=4), dimension(size) :: var, buff, average
       do i=1,size
         var(i)=var(i) + (buff(i)-average(i))**2
       enddo
       return
       end

       subroutine add_quad_var_double (var, buff, average, size)
       implicit none
       integer size, i
       real(kind=8), dimension(size) :: var, buff, average
       do i=1,size
         var(i)=var(i) + (buff(i)-average(i))**2
       enddo
       return
       end
# else

       subroutine add_buff_to_var_real (var, buff, size)
       implicit none
       integer size, i
       real(kind=4), dimension(size) :: var, buff
       do i=1,size
         var(i)=var(i) + buff(i)
       enddo
       end

       subroutine add_buff_to_var_double (var, buff, size)
       implicit none
       integer size, i
       real(kind=8), dimension(size) :: var, buff
       do i=1,size
         var(i)=var(i) + buff(i)
       enddo
       end
# endif
#endif

#ifndef READ
# define READ
# include "read_add_write.F"
#else
# ifndef READ_AND_ADD
#  define READ_AND_ADD
#  include "read_add_write.F"
# else
#  ifndef QUAD_VARIANCE
#   define QUAD_VARIANCE
#   include "read_add_write.F"
#  endif
# endif
#endif
