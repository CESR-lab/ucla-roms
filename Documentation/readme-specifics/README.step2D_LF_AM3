Dear Hernan and All,

This is pretty much my final say about step2D_LF_AM3.F, at least
related to LF-TR/LF-AM3 version. There is also a Forward-Backward
version of barotropic mode bat it is a different story.

I hast wondering whether you can adapt it.

The following code has tunable time-stepping coefficient and, if
chosen for maximum stability, it allows approximately 25...33% larger
barotropic time step than the existing version in Rutgers beta 7
code. (previous settings are also included for reference.) 


The second significant difference is that it is reorganized in such
a way that shared arrays for r.h.s. of "zeta", "ubar" and "vbar"
(shared arrays "rzeta", "rubar" and "rvbar") have been eliminated
altogether, which results in overall a more efficient code (mostly
due to the fact that the probability of false sharing events is
reduced by a factor of two, since this code modifies only three
shared 2D arrays per time step (not six, as it was before). It also
results in a much simpler barotropic time averaging procedure, since
it is no longer necessary to keep track of all that 5/12, -1/12 and
2/3 and the associated startup procedure.


The other distinction is that the need for the additional time step
in the driving routine (associated with synchronization and delayed
mode computation of fast-time-averages) has been eliminated. 

The primary motivation to do both changes is due to the fact that 
that the other companion, the Forward-Backward version uses entirely
different index rolling algorithm and having that additional time
step was too much hassle to straighten it up: in the present version
for both version the 2D time index rolling is continuous between
3D time stepping (pretty much the same as it used to be in SCRUM 3.0
code), and yet all synchronization issues have been worked out. 



I am planning to drop supporting hyperviscosity in 2D: I view its
numerical value as too low to justify the hassle is brings into MPI
code (it requires an extra ghost point for zeta and h, and/or extra
messages: the procedure of setting extra periodic boundaries for
the "first Laplacian" is illegal in MPI code). As the result, I made
no attempt to "improve" this part of the code and make it "physically
consistent". The rest of the code is pretty much up to date.


As for the conventional viscosity, I am using somewhat simplified
form of a symmetric tensor: I do not scurpulusly recover (as Hernan
does) all bits associated with curvilinear transformation metric.
This is somewhat similar to POM. This may be recovered, but I do
not believe that it makes any difference in practice. 



Minor, but important thing:  time index "krhs" has been excluded
====== === ========= ======  from common block "scalars.h". It exist
only as an internal variable in step2D_tile. Keeping it there while
using the new code would cause false sharing. 


The driver now looks like: [NOTE: 1. "do iif=1,nfast", it is no
=== ====== === ===== =====           longer "do iif=1,nfast+1";

                                  2. Of course, since this is my
  fragment of main.F                 code, ZIG_ZAG tile processing
  -------- -- ------                 sequence is generated by
                                     mpc-pre-processor rather than
                                     by hand, like in Hernan's code.

                                  3. For the same reason you will not
                                     see all that BIGREAL / REAL_TYPE
                                     0.5_r8 etc stuff.]
#ifdef SOLVE3D
        do iif=1,nfast
#endif
          kstp=next_kstp
          knew=3
CSDOACROSS LOCAL(tile)
          do tile=0,NSUB_X*NSUB_E-1
#ifndef SOLVE3D
            call set_vbc (tile)
# ifdef ZNUDGING
#  ifdef ANA_SSH
            call ana_ssh (tile)
#  else
            call set_ssh (tile)
#  endif
# endif
#endif
            call step2d (tile)
          enddo

#ifndef SOLVE3D
          if (may_day_flag.ne.0) goto 99 !-->  EXIT
#endif
          knew=3-kstp
          next_kstp=knew
CSDOACROSS LOCAL(tile)
          do tile=0,NSUB_X*NSUB_E-1
             call step2d (tile)
          enddo

#ifdef SOLVE3D
        enddo
#endif

 

I am sending the actual step2d code as a separate message immediately
following this one.

Sasha



 
