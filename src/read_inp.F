#include "cppdefs.opt"
                                        ! Read and report model input
      subroutine read_inp(ierr)         ! parameters from keyword-based
                                        ! startup file.

      use param
      use surf_flux
      use tracers, only: wrt_t, t_vname, wrt_t_avg
      use boundary
      use eos_vars
      use basic_output
      use scalars
      use scoord
      use mpi
      use roms_read_write

      implicit none
      integer ierr

      integer, parameter :: input=15, testunit=40,
     &                  max_fname=256, max_kwsize=99
      character(len=max_fname)  :: fname
      character(len=max_kwsize) :: keyword
      character(len=3), parameter :: end_signal='end'
      integer is,ie,  kwlen, lstr, lenstr
#ifdef SOLVE3D
     &                                 , itrc
#endif
#ifdef INT_IARGC
      integer iargc
#endif

! Check CPP-switches for consistency. This operation is split into
! multiple stages because the first subroutine, "check_switches1", is
! generated by special program cppcheck (file cppcheck.F) by examining
! and documention all CPP-switches appearing in "cppdefs.opt" regardless
! of their context, and automatically generate a code to keep track of
! their status, as well as to traps multiply defined global
! configurations (project switches, such as PACIFIC, USWEST, DAMEE_B,
! etc).  The subsequent routines are to track locally-defined switches
! in few other places throughout the code (these routines are
! hand-written), and, finally, the last routine, "check_switches2"
! contains traps for mutually exclussive definitions of non-project
! switches (e.g. it traps multiply defined vertical mixing schemes or
! lateral boundary conditions; this code is also hand written).
! All the checking routines codes are written in transparent mode:
! they assumed that error flag (ierr) is initialized at the entry and
! they add 1 for each error discovered.

      ierr=0                      ! <-- reset error counter
      call check_tiling(ierr)
      call check_switches1(ierr)
#ifdef SOLVE3D
      call check_pre_step_switches(ierr)
      call check_step_uv1_switches(ierr)
      call check_step_uv2_switches(ierr)
      call check_step_t_switches(ierr)
      call check_set_HUV1_switches(ierr)
# ifdef LMD_KPP
      call check_kpp_switches(ierr)
# endif
      call check_switches2(ierr)
#endif
      if (ierr /= 0) return
      mpi_master_only call print_switches

! Use pre-set default startup filename for known applications, or
! get it as an argument from command line via iargc-getarg (override
! default). NOTE: The usage of the executable should be either
!
!              roms
!        or
!              roms startup_file_name
!
! WITHOUT the UNIX redirection (<): roms < startup_file like it
! used to be.

      fname='roms.in'  !<-- default
#ifdef MPI
      if (mynode == 0) then
#endif
        is=iargc() ; if (is == 1) call getarg(is,fname)
#ifdef MPI
      endif
      call MPI_Bcast(fname,64,MPI_BYTE, 0, ocean_grid_comm, ierr)
#endif

! Read in keyword name: keep trying, until keyword is found.
!----- -- ------- ----- ---- ------- ------ ------- ---------

      call setup_kwds(ierr)
      open(input, file=fname, status='old', form='formatted', err=97)
   1   keyword='                                '
       read(input,'(A)',err=1,end=99) keyword
       if (keyword(1:1) == '!') goto 1
       is=1
   2   if (is == max_kwsize) then
         goto 1
       elseif (keyword(is:is) == ' ') then
         is=is+1
         goto 2
       endif
       ie=is
   3   if (keyword(ie:ie) == ':') then
         keyword(ie:ie)=' '
         goto 4           !--> recognized keyword.
       elseif (keyword(ie:ie) /= ' ' .and. ie < max_kwsize) then
         ie=ie+1
         goto 3
       endif
       goto 1
   4   kwlen=ie-is
       if (is > 1) keyword(1:kwlen)=keyword(is:is+kwlen-1)

! Read input parameters according to the keyword:
!----- ----- ---------- --------- --- ---- -------

! Title

        if (keyword(1:kwlen) == 'title') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) title
          lstr=lenstr(title)
          mpi_master_only write(*,'(/1x,A)') title(1:lstr)

! Time-stepping parameters

        elseif (keyword(1:kwlen) == 'time_stepping') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) ntimes, dt, ndtfast, ninfo
          mpi_master_only write(*,
     &  '(5x,A,I10,3x,A/9x,A,F11.4,2x,A/4x,A,I10,3x,A/6x,A,I10,3x,2A)'
     &    ) 'ntimes =',  ntimes, 'total number of 3D timesteps',
     &          'dt =',     dt,  'time step [sec] for 3D equations',
     &     'ndtfast =', ndtfast, 'mode-splitting ratio',
     &       'ninfo =',   ninfo, 'number of steps between runtime ',
     &                                              'diagnostics'

          dtfast=dt/dble(ndtfast)     ! set barotropic time step.
#ifndef SOLVE3D
          dt=dtfast
          ntimes=ntimes*ndtfast
          ninfo=ninfo*ndtfast
#endif

! Vertical S-coordinates transformation. Note that "hc" may be chosen
! to be very large (infinity) if vertically uniform sigma is desired.

#ifdef SOLVE3D
        elseif (keyword(1:kwlen) == 'S-coord') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) theta_s, theta_b, hc
          mpi_master_only write(*,'(2(/4x,A,F10.7,2x,A))')
     &    'theta_s =', theta_s, 'vertical S-coordinate surface',
     &    'theta_b =', theta_b, 'and bottom stretching parameters'
          if (hc < 1000.) then
            mpi_master_only write(*,'(9x,A,F10.5,2x,2A)')
     &                   'hc =', hc, 'critical depth [m]'
          else
            mpi_master_only write(*,'(9x,A,ES14.5,2x,2A)')
     &                   'hc =', hc, 'critical depth [m]'
          endif

!--> Boussinesq  reference density.

        elseif (keyword(1:kwlen) == 'rho0') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) rho0
          mpi_master_only write(*,'(7x,A,F10.4,2x,A)')  'rho0 =',
     &            rho0, 'Boussinesq reference density [kg/m^3].'

# ifndef NONLIN_EOS
!--> Parameters for linear equations of state.

        elseif (keyword(1:kwlen) == 'lin_rho_eos') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) Tcoef, T0
#  ifdef SALINITY
     &                       , Scoef, S0
#  endif
          mpi_master_only write(*,'(4(6x,A,F10.4,2x,A/))')
     &      'Tcoef =', Tcoef,  'thermal expansion [kg/m^3/deg C]'
     &    , '   T0 =',    T0,  'reference temperature [deg C]'
#  ifdef SALINITY
     &    , 'Scoef =', Scoef,  'saline contraction [kg/m^3/PSU]'
     &    , '   S0 =',    S0,  'reference salinity [PSU]'
#  endif
# endif
#endif /* SOLVE3D */


#ifdef UV_VIS2
! Lateral viscosity coefficients.

        elseif (keyword(1:kwlen) == 'lateral_visc') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) visc2
          mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')   'visc2 =',
     &    visc2, 'horizontal Laplacian kinematic viscosity [m^2/s]'


# if !defined EW_PERIODIC || !defined NS_PERIODIC
! Lateral boundary slipperness.

        elseif (keyword(1:kwlen) == 'gamma2') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) gamma2
          mpi_master_only write(*,'(5x,A,ES10.3,2x,2A)') 'gamma2 =',
     &                           gamma2, 'slipperiness parameter: ', 
     &                           'free-slip = +1, or no-slip = -1.'
# endif
#endif
#ifdef SOLVE3D
# ifdef TS_DIF2
! Horizontal Laplacian mixing coefficients for tracers.

        elseif (keyword(1:kwlen) == 'tracer_diff2') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) (tnu2(itrc),itrc=1,NT)
          do itrc=1,NT
            if (itrc == itemp) then
              mpi_master_only write(*,'(3x,A,I2,A,ES10.3,2x,2A,I2,A)')
     &         'tnu2(',itrc,') =',tnu2(itrc),'horizontal Laplacian ',
     &         'kinematic heat conductivity [m^2/s]'
            else
              mpi_master_only write(*,'(3x,A,I2,A,ES10.3,2x,2A,I2,A)')
     &         'tnu2(',itrc,') =',tnu2(itrc),'horizontal Laplacian ',
     &         'diffusion for tracer ', itrc, ', [m^2/s]'
            endif
          enddo
# endif
#endif

! Bottom drag coefficients.

        elseif (keyword(1:kwlen) == 'bottom_drag') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) rdrg, rdrg2
#ifdef SOLVE3D
     &                             , Zob
#endif
          mpi_master_only write(*,'(7x,A,ES10.3,2x,A)')
     &     'rdrg =', rdrg,  'linear bottom drag coefficient [m/s]'
          mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')
     &    'rdrg2 =', rdrg2, 'quadratic bottom drag coefficient, nondim'
#ifdef SOLVE3D
          mpi_master_only write(*,'(8x,A,ES10.3,2x,A)')
     &  ,   'Zob =', Zob,   'bottom roughness height [m]'
#endif

#ifdef SOLVE3D
# if !defined LMD_MIXING && !defined BVF_MIXING && !defined PP_MIXING\
                         && !defined MY2_MIXING && !defined MY25_MIXING

! Background vertical viscosity and mixing coefficients for tracers.

        elseif (keyword(1:kwlen) == 'vertical_mixing') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) Akv_bak,(Akt_bak(itrc),itrc=1,NT)
          mpi_master_only write(*,'(4x,A,ES10.3,2x,A)')  'Akv_bak =',
     &               Akv_bak, 'background vertical viscosity [m^2/s]'
          do itrc=1,NT
            mpi_master_only write(*,'(1x,A,I1,A,ES10.3,2x,2A)')
     &                     'Akt_bak(',  itrc,  ') =',  Akt_bak(itrc),
     &                     'background vertical mixing [m^2/s] for ',
     &        vname(2,indxT+itrc-1)(1:lenstr(vname(2,indxT+itrc-1)))
          enddo
# endif
# ifdef MY25_MIXING
! Mellor-Yamada Level 2.5 turbulent closure parameters.

        elseif (keyword(1:kwlen) == 'MY_bak_mixing') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) Akq_bak, q2nu2, q2nu4
          mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')  'Akq_bak =',
     &        Akq_bak, 'Background vertical mixing for TKE, [m^2/s]'
#  ifdef Q_DIF2
          mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')    'q2nu2 =',
     &         q2nu2, 'Horizontal Laplacian mixing for TKE, [m^2/s]'
#  endif
#  ifdef Q_DIF4
          mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')    'q2nu4 =',
     &        q2nu4, 'Horizontal biharmonic mixing for TKE, [m^4/s]'
#  endif
# endif

# if defined SFLX_CORR && defined SALINITY

        elseif (keyword(1:kwlen) == 'SSS_correction') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) dSSSdt
          mpi_master_only write(*,'(5x,A,ES10.3,2x,2A/38x,A)')
     &   'dSSSdt =', dSSSdt, 'Sea-Surface Salinity correction ',
     &                       'coefficient expressed',
     &            'kinematically as "piston velocity" [cm/day]' 

          dSSSdt=dSSSdt/(100*day2sec)   !<-- Convert cm/day to convert to [m/s]
          ! This is also defined in put_global_atts so needs to be consistent.
           
# endif

# if defined QCORRECTION

        elseif (keyword(1:kwlen) == 'SST_correction') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) dSSTdt
          mpi_master_only write(*,'(5x,A,ES10.3,2x,2A/38x,A)')
     &   'dSSTdt =', dSSTdt, 'Sea-Surface Temperature correction ',
     &                       'coefficient expressed',
     &            'kinematically as "piston velocity" [cm/day]'

          dSSTdt=dSSTdt/(100*day2sec)   !<-- Convert cm/day to convert to [m/s]
          ! This is also defined in put_global_atts so needs to be consistent.

# endif

#endif /* SOLVE3D */



#if  defined T_FRC_BRY || defined M2_FRC_BRY || defined TNUDGING \
  || defined Z_FRC_BRY || defined M3_FRC_BRY || defined M2NUDGING \
                       || defined M3NUDGING  || defined WKB_FRC_BRY

        elseif (keyword(1:kwlen) == 'ubind') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) ubind
            mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')
     &     'ubind =', ubind, 'open boundary binding velcity [m/s]'


/* OBSOLETE --->
! Parameters for OBC nudging and nudging layers;
! converted from [days] to [sec^-1]


c-->    elseif (keyword(1:kwlen) == 'nudg_cof') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) tauM2_in, tauM2_out, attnM2
# ifdef SOLVE3D
     &                       , tauM3_in, tauM3_out
     &                       , tauT_in,  tauT_out
# endif
          if (tauM2_in > 0.) then                ! convert relaxation
            tauM2_in =1./(tauM2_in *day2sec)     ! time [units = days]
          endif                                  ! into
          if (tauM2_out > 0.) then               ! nudging coefficient
            tauM2_out=1./(tauM2_out*day2sec)     ! [units = 1/sec]
          endif
# ifdef SOLVE3D
          if (tauM3_in > 0.) then
            tauM3_in =1./(tauM3_in *day2sec)
          endif
          if (tauM3_out > 0.) then
            tauM3_out=1./(tauM3_out*day2sec)
          endif
          if (tauT_in > 0.) then
            tauT_in =1./(tauT_in *day2sec)
          endif
          if (tauT_out > 0.) then
            tauT_out=1./(tauT_out*day2sec)
          endif
# endif
          mpi_master_only write(*,'(6x,A,ES10.3,ES10.3,2A)')
     &          'tauM2 =', tauM2_in, tauM2_out, '(in/out)  Nudging ',
     &                                   'for barotropic mode [s^-1]'
          mpi_master_only write(*,'(5x,A,ES10.3,2x,2A)') 'attnM2 =',
     &    attnM2,'open boundary pressure-gradient attenuation [s^-1]'
# ifdef SOLVE3D
          mpi_master_only write(*,'(6x,A,ES10.3,ES10.3,2A)')
     &          'tauM3 =', tauM3_in, tauM3_out, '(in/out)  Nudging ',
     &                                   'for baroclinic mode [s^-1]'
          mpi_master_only write(*,'(7x,A,ES10.3,ES10.3,2A)')
     &             'tauT =', tauT_in, tauT_out, '(in/out)  Nudging ',
     &                                          'for tracers [s^-1]'
# endif
           <--- OBSOLETE */
#endif


#ifdef SPONGE
! Parameters for the sponge layers

        elseif (keyword(1:kwlen) == 'v_sponge') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) v_sponge
          mpi_master_only write(*,'(3x,A,F10.2,2x,A)') 'v_sponge =',
     &        v_sponge, 'maximum viscosity in sponge layer [m^2/s]'
#endif

! Input file controls:  grid, initial conditions, surface forcing,
!----- ----- ---------  lateral boundary forcing data

#ifndef ANA_GRID
! Grid file name. Check its availability.

        elseif (keyword(1:kwlen) == 'grid') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node(fname, lstr, mynode, NNODES, ierr)
!         call insert_nodes(fname)
# endif
          open(testunit,file=fname(1:lstr), status='old', err=97)
          close(testunit)
          grdname=fname(1:lstr)
          mpi_master_only write(*,'(1x,2A)') 'grid file: ',
     &                                     grdname(1:lstr)
#endif

! Initial conditions file name. Check its availability (in the case
! of analytical initial conditions and nrrec=0 initial conditions are
! created internally and no file is needed).

        elseif (keyword(1:kwlen) == 'initial') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) nrrec
#ifdef ANA_INITIAL
          if (nrrec > 0) then
#endif
            read(input,'(A)',err=95) fname
            lstr=lenstr(fname)
#if defined MPI && defined PARALLEL_FILES
            call insert_node(fname, lstr, mynode, NNODES, ierr)
#endif
            ininame=fname(1:lstr)
            mpi_master_only write(*,'(1x,A,I3,2x,3A)')
     &       'initial condition :: rec =', nrrec,  'file = ''',
     &                                   ininame(1:lstr), ''''
#ifdef ANA_INITIAL
          endif
#endif

! Forcing file name. Check its availability.

        elseif (keyword(1:kwlen) == 'forcing') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          max_frc=0
          lstr=1
          do while(lstr > 0 .and. max_frc < max_frc_files+1)
            read(input,'(A)',err=95) fname
            lstr=lenstr(fname)
            if (lstr > 0) then
# if defined MPI && defined PARALLEL_FILES
              call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif
              open(testunit,file=fname(1:lstr),status='old',err=97)
              close(testunit)

              if (max_frc < max_frc_files) then
                max_frc=max_frc+1
                frcfile(max_frc)=fname(1:lstr)
# ifdef MPI_SILENT_MODE
                if (mynode == 0) then
# endif
                  if (max_frc == 1) then
                    write(*,'(1x,2A)') 'forcing data file(s): ',
     &                                 frcfile(max_frc)(1:lstr)
                  else
                    write(*,'(23x,A)') frcfile(max_frc)(1:lstr)
                  endif

# ifdef MPI_SILENT_MODE
                endif
# endif
              else
                mpi_master_only write(*,'(1x,2A/12x,2A/)')
     &          '### ERROR: read_inp :: Too many forcing files are ',
     &          'specified in input script.',  'Increase parameter ',
     &                '''max_frc_files'' in roms_read_write and recompile.'
                ierr=ierr+1
              endif
            endif
          enddo


! Climatology file name. Climatology data is needed for (1) to supply
! boundary data for T,S,u,v at open boundaries (just one row of points)
! and (2) nudging to T,S data inside the domain within the  nudging
! finite-width band near the boundary [although depreciated,  this
! practice  remains in some applications; doing so for u,v is no
! longer supported by this code].  Aternatively to (1), the boundary
! data may also be supplied via BRY mechanism, where file contains
! perimeter data only.  In this case (activated by T_FRC_BRY), no
! climatology file is needed.  The following code segments also
! checks for availability of clm_file.

#if defined SOLVE3D &&( defined TCLIMATOLOGY ||( defined TNUDGING && \
                        defined T_FRC_BRY )) && !defined ANA_TCLIMA

        elseif (keyword(1:kwlen) == 'climatology') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif
          open(testunit, file=fname(1:lstr), status='old', err=97)
          close(testunit)
          clm_file=fname(1:lstr)
          mpi_master_only write(*,'(1x,4A)')   'climatology data :: ',
     &                           'file = ''', clm_file(1:lstr), ''''
#endif

! Read output file root name using roms_read_write.F module
        elseif (keyword(1:kwlen).eq.'output_root_name') then
          call read_output_root_name(keyword, kwlen)

        else
          mpi_master_only write(*,'(/1x,4A/)') 'WARNING: ',
     &                'Urecognized keyword ''', keyword(1:kwlen),
     &                                      ''' --> DISREGARDED.'
        endif
       if (keyword(1:kwlen) == end_signal) goto 99
      goto 1

! Error while reading input parameters.

  95  write(*,'(/1x,4A/)') '### ERROR: read_inp :: Cannot read ',
     &                       'entry ''', keyword(1:kwlen), '''.'
      ierr=ierr+1
      goto 99
  97  lstr=lenstr(fname)
      write(*,'(/i4,1x,4A/)') mynode,'### ERROR: read_inp :: Cannot find ',
     &                     'input file ''', fname(1:lstr), '''.'
      ierr=ierr+1
  99  close (input)

! Check that all keywords were canceled, complain about the error,
! if some of them left.

      if (ierr == 0) call check_kwds (ierr)
      if (ierr /= 0) then
        write(*,'(/1x,2A,I3,1x,A/)') '### ERROR: read_inp :: ',
     &  'A total of', ierr, 'configuration errors discovered.'
       return
      endif
      call check_srcs
#ifdef MPI
      call MPI_Barrier (ocean_grid_comm, ierr)
#endif
      end

                                            ! Find place in the string
      subroutine cancel_kwd(keyword, ierr)  ! kwds(1:max_opt_size)
      use strings
      implicit none                         ! which matches the input

      character(len=*) keyword              ! keyword name and turn it
      integer ierr, is,i,ie, lenkw,lenstr   ! into blank. Complain
      lenkw=lenstr(keyword)                 ! about error if not found.
      is=1
      do while (is>0 .and. is<max_opt_size)
        do while (kwds(is:is)==' ' .and. is<max_opt_size)
          is=is+1
        enddo
        ie=is+1
        do while (kwds(ie:ie)/=' ' .and. ie<max_opt_size)
          ie=ie+1
        enddo
        if (lenkw==ie-is .and. kwds(is:ie-1)==keyword) then
c**       write(*,'(1x,A,1x,A)') 'Recognized: ', kwds(is:ie-1)
          do i=is,ie-1
            kwds(i:i)=' '
          enddo
          is=0         !--> to signal that keyword is found and
        else           !                      terminate the search
          is=ie        !--> skip to the next word in "kwds" string
        endif
      enddo
      if (is/=0) then
        write(*,'(/A)') '##### ERROR #####'
        write(*,'(2(1x,A,1x,A,1x,A/)/)') 'cancel_kwd:',
     &         'Can not cancel keyword:',  keyword(1:lenkw),
     &         'check input script for possible',
     &         'duplicated keywords.'
        write(*,'(A/)') '#################'
        ierr=ierr+1
      endif
      end

                                      ! Check that keyword string is
      subroutine check_kwds (ierr)    ! empty, and if it is not print
      use strings
      implicit none                   ! out remaining keyword(s) as

      integer ierr, is,ie             ! an error message and increase
      is=1                            ! error counter ierr.
      do while (is<max_opt_size)
        do while (kwds(is:is)==' ' .and. is<max_opt_size)
          is=is+1
        enddo
        if (is<max_opt_size) then
          ie=is+1
          do while (kwds(ie:ie)/=' ' .and. ie<max_opt_size)
            ie=ie+1
          enddo
          ierr=ierr+1
          write(*,'(/1x,A,1x,A/)') '### ERROR: keyword not found:',
     &                                               kwds(is:ie-1)
          is=ie
        endif
      enddo
      end


