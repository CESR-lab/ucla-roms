#include "cppdefs.h"
                                        ! Read and report model input
      subroutine read_inp(ierr)         ! parameters from keyword-based
                                        ! startup file.

      use param
#ifdef WEC
      use wec_frc, only: read_inp_wec, read_inp_avg_wec
#endif
      use surf_flux
      use tracers, only: wrt_t, t_vname, wrt_t_avg
      use read_write ! , only: read_output_root_name, expanse_scratch_env_var
      use boundary
      use eos_vars

      implicit none
      integer ierr
#include "scoord.h"
#include "scalars.h"
#include "ncvars.h"
#ifdef MPI
# include "mpif.h"
#endif
      integer, parameter :: input=15, testunit=40,
     &                  max_fname=256, max_kwsize=99
      character(len=max_fname)  :: fname
      character(len=max_kwsize) :: keyword
      character(len=3), parameter :: end_signal='end'
      integer is,ie,  kwlen, lstr, lenstr
#ifdef SOLVE3D
     &                                 , itrc
#endif
#ifdef INT_IARGC
      integer iargc
#endif

! Check CPP-switches for consistency. This operation is split into
! multiple stages because the first subroutine, "check_switches1", is
! generated by special program cppcheck (file cppcheck.F) by examining
! and documention all CPP-switches appearing in "cppdefs.h" regardless
! of their context, and automatically generate a code to keep track of
! their status, as well as to traps multiply defined global
! configurations (project switches, such as PACIFIC, USWEST, DAMEE_B,
! etc).  The subsequent routines are to track locally-defined switches
! in few other places throughout the code (these routines are
! hand-written), and, finally, the last routine, "check_switches2"
! contains traps for mutually exclussive definitions of non-project
! switches (e.g. it traps multiply defined vertical mixing schemes or
! lateral boundary conditions; this code is also hand written).
! All the checking routines codes are written in transparent mode:
! they assumed that error flag (ierr) is initialized at the entry and
! they add 1 for each error discovered.

      ierr=0                      ! <-- reset error counter
      call check_tiling(ierr)
      call check_switches1(ierr)
#ifdef SOLVE3D
      call check_scoord_switches(ierr)
      call check_pre_step_switches(ierr)
      call check_step_uv1_switches(ierr)
      call check_step_uv2_switches(ierr)
      call check_step_t_switches(ierr)
      call check_set_HUV1_switches(ierr)
# ifdef LMD_KPP
      call check_kpp_switches(ierr)
# endif
      call check_switches2(ierr)
#endif
      if (ierr /= 0) return
      mpi_master_only call print_switches

! Use pre-set default startup filename for known applications, or
! get it as an argument from command line via iargc-getarg (override
! default). NOTE: The usage of the executable should be either
!
!              roms
!        or
!              roms startup_file_name
!
! WITHOUT the UNIX redirection (<): roms < startup_file like it
! used to be.

#if defined SOLITON
      fname='roms.in.Soliton'
#elif defined SEAMOUNT
      fname='roms.in.Seamount'
#elif defined WAVE_RAD
      fname='roms.in.WaveRad'
#elif defined ISWAKE
      fname='roms.in.IsWake'
#elif defined UPWELLING
      fname='roms.in.Upwelling'
#elif defined GRAV_ADJ
      fname='roms.in.GravAdj'
#elif defined IBERIA
      fname='roms.in.Iberia'
#elif defined RIVER
      fname='roms.in.River'
#elif defined PACIFIC
      fname='pacific.in'
#elif defined PACIFIC_2D
      fname='pacific_2D.in'
#elif defined CANBAS2
c--      fname='canBas2.in'
c--      fname='cblanco.in'
      fname='unpr.in'
#elif defined SPIRAL
      fname='spiral.in'
#elif defined PACBIG
      fname='pacbig.in'
#elif defined NWPAC
      fname='nwp.in'
#elif defined SMSC
      fname='smsc.in'
#elif defined SMSC_SUB
      fname='smsc_sub.in'
#elif defined USWEST
      fname='mb_l1_safe.in'
c--      fname='roms.in.USW20'
c--      fname='roms.in.US_West'
#elif defined SCB_TEST
      fname='scb_test.in'
#elif defined DAMEE_B
      fname='roms.in.Atl4'
#else
      fname='roms.in'  !<-- default
#endif
#ifdef MPI
      if (mynode == 0) then
#endif
        is=iargc() ; if (is == 1) call getarg(is,fname)
#ifdef MPI
      endif
      call MPI_Bcast(fname,64,MPI_BYTE, 0, ocean_grid_comm, ierr)
#endif

      wrthis(indxTime)=.false.
#ifdef AVERAGES
      wrtavg(indxTime)=.false.
#endif

! Read in keyword name: keep trying, until keyword is found.
!----- -- ------- ----- ---- ------- ------ ------- ---------

      call setup_kwds(ierr)
      open(input, file=fname, status='old', form='formatted', err=97)
   1   keyword='                                '
       read(input,'(A)',err=1,end=99) keyword
       if (keyword(1:1) == '!') goto 1
       is=1
   2   if (is == max_kwsize) then
         goto 1
       elseif (keyword(is:is) == ' ') then
         is=is+1
         goto 2
       endif
       ie=is
   3   if (keyword(ie:ie) == ':') then
         keyword(ie:ie)=' '
         goto 4           !--> recognized keyword.
       elseif (keyword(ie:ie) /= ' ' .and. ie < max_kwsize) then
         ie=ie+1
         goto 3
       endif
       goto 1
   4   kwlen=ie-is
       if (is > 1) keyword(1:kwlen)=keyword(is:is+kwlen-1)

! Read input parameters according to the keyword:
!----- ----- ---------- --------- --- ---- -------

! Title

        if (keyword(1:kwlen) == 'title') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) title
          lstr=lenstr(title)
          mpi_master_only write(*,'(/1x,A)') title(1:lstr)

! Time-stepping parameters

        elseif (keyword(1:kwlen) == 'time_stepping') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) ntimes, dt, ndtfast, ninfo
          mpi_master_only write(*,
     &  '(5x,A,I10,3x,A/9x,A,F11.4,2x,A/4x,A,I10,3x,A/6x,A,I10,3x,2A)'
     &    ) 'ntimes =',  ntimes, 'total number of 3D timesteps',
     &          'dt =',     dt,  'time step [sec] for 3D equations',
     &     'ndtfast =', ndtfast, 'mode-splitting ratio',
     &       'ninfo =',   ninfo, 'number of steps between runtime ',
     &                                              'diagnostics'

          dtfast=dt/dble(ndtfast)     ! set barotropic time step.
#ifndef SOLVE3D
          dt=dtfast
          ntimes=ntimes*ndtfast
          ninfo=ninfo*ndtfast
#endif

! Vertical S-coordinates transformation. Note that "hc" may be chosen
! to be very large (infinity) if vertically uniform sigma is desired.

#ifdef SOLVE3D
        elseif (keyword(1:kwlen) == 'S-coord') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) theta_s, theta_b, hc
          mpi_master_only write(*,'(2(/4x,A,F10.7,2x,A))')
     &    'theta_s =', theta_s, 'vertical S-coordinate surface',
     &    'theta_b =', theta_b, 'and bottom stretching parameters'
          if (hc < 1000.) then
            mpi_master_only write(*,'(9x,A,F10.5,2x,2A)')
     &                   'hc =', hc, 'critical depth [m]'
          else
            mpi_master_only write(*,'(9x,A,ES14.5,2x,2A)')
     &                   'hc =', hc, 'critical depth [m]'
          endif

!--> Boussinesq  reference density.

        elseif (keyword(1:kwlen) == 'rho0') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) rho0
          mpi_master_only write(*,'(7x,A,F10.4,2x,A)')  'rho0 =',
     &            rho0, 'Boussinesq reference density [kg/m^3].'

# ifndef NONLIN_EOS
!--> Parameters for linear equations of state.

        elseif (keyword(1:kwlen) == 'lin_rho_eos') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) Tcoef, T0
#  ifdef SALINITY
     &                       , Scoef, S0
#  endif
          mpi_master_only write(*,'(4(6x,A,F10.4,2x,A/))')
     &      'Tcoef =', Tcoef,  'thermal expansion [kg/m^3/deg C]'
     &    , '   T0 =',    T0,  'reference temperature [deg C]'
#  ifdef SALINITY
     &    , 'Scoef =', Scoef,  'saline contraction [kg/m^3/PSU]'
     &    , '   S0 =',    S0,  'reference salinity [PSU]'
#  endif
# endif
#endif /* SOLVE3D */


#ifdef UV_VIS2
! Lateral viscosity coefficients.

        elseif (keyword(1:kwlen) == 'lateral_visc') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) visc2
          mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')   'visc2 =',
     &    visc2, 'horizontal Laplacian kinematic viscosity [m^2/s]'


# if !defined EW_PERIODIC || !defined NS_PERIODIC
! Lateral boundary slipperness.

        elseif (keyword(1:kwlen) == 'gamma2') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) gamma2
          mpi_master_only write(*,'(5x,A,ES10.3,2x,2A)') 'gamma2 =',
     &                           gamma2, 'slipperiness parameter: ', 
     &                           'free-slip = +1, or no-slip = -1.'
# endif
#endif
#ifdef SOLVE3D
# ifdef TS_DIF2
! Horizontal Laplacian mixing coefficients for tracers.

        elseif (keyword(1:kwlen) == 'tracer_diff2') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) (tnu2(itrc),itrc=1,NT)
          do itrc=1,NT
            if (itrc == itemp) then
              mpi_master_only write(*,'(3x,A,I2,A,ES10.3,2x,2A,I2,A)')
     &         'tnu2(',itrc,') =',tnu2(itrc),'horizontal Laplacian ',
     &         'kinematic heat conductivity [m^2/s]'
            else
              mpi_master_only write(*,'(3x,A,I2,A,ES10.3,2x,2A,I2,A)')
     &         'tnu2(',itrc,') =',tnu2(itrc),'horizontal Laplacian ',
     &         'diffusion for tracer ', itrc, ', [m^2/s]'
            endif
          enddo
# endif
#endif

! Bottom drag coefficients.

        elseif (keyword(1:kwlen) == 'bottom_drag') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) rdrg, rdrg2
#ifdef SOLVE3D
     &                             , Zob
#endif
          mpi_master_only write(*,'(7x,A,ES10.3,2x,A)')
     &     'rdrg =', rdrg,  'linear bottom drag coefficient [m/s]'
          mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')
     &    'rdrg2 =', rdrg2, 'quadratic bottom drag coefficient, nondim'
#ifdef SOLVE3D
          mpi_master_only write(*,'(8x,A,ES10.3,2x,A)')
     &  ,   'Zob =', Zob,   'bottom roughness height [m]'
#endif

#ifdef SOLVE3D
# if !defined LMD_MIXING && !defined BVF_MIXING && !defined PP_MIXING\
                         && !defined MY2_MIXING && !defined MY25_MIXING

! Background vertical viscosity and mixing coefficients for tracers.

        elseif (keyword(1:kwlen) == 'vertical_mixing') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) Akv_bak,(Akt_bak(itrc),itrc=1,NT)
          mpi_master_only write(*,'(4x,A,ES10.3,2x,A)')  'Akv_bak =',
     &               Akv_bak, 'background vertical viscosity [m^2/s]'
          do itrc=1,NT
            mpi_master_only write(*,'(1x,A,I1,A,ES10.3,2x,2A)')
     &                     'Akt_bak(',  itrc,  ') =',  Akt_bak(itrc),
     &                     'background vertical mixing [m^2/s] for ',
     &        vname(2,indxT+itrc-1)(1:lenstr(vname(2,indxT+itrc-1)))
          enddo
# endif
# ifdef MY25_MIXING
! Mellor-Yamada Level 2.5 turbulent closure parameters.

        elseif (keyword(1:kwlen) == 'MY_bak_mixing') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) Akq_bak, q2nu2, q2nu4
          mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')  'Akq_bak =',
     &        Akq_bak, 'Background vertical mixing for TKE, [m^2/s]'
#  ifdef Q_DIF2
          mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')    'q2nu2 =',
     &         q2nu2, 'Horizontal Laplacian mixing for TKE, [m^2/s]'
#  endif
#  ifdef Q_DIF4
          mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')    'q2nu4 =',
     &        q2nu4, 'Horizontal biharmonic mixing for TKE, [m^4/s]'
#  endif
# endif

# if defined SFLX_CORR && defined SALINITY

        elseif (keyword(1:kwlen) == 'SSS_correction') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) dSSSdt
          mpi_master_only write(*,'(5x,A,ES10.3,2x,2A/38x,A)')
     &   'dSSSdt =', dSSSdt, 'Sea-Surface Salinity correction ',
     &                       'coefficient expressed',
     &            'kinematically as "piston velocity" [cm/day]' 

          dSSSdt=dSSSdt/(100*day2sec)   !<-- Convert cm/day to convert to [m/s]
          ! This is also defined in put_global_atts so needs to be consistent.
           
# endif

# if defined QCORRECTION

        elseif (keyword(1:kwlen) == 'SST_correction') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) dSSTdt
          mpi_master_only write(*,'(5x,A,ES10.3,2x,2A/38x,A)')
     &   'dSSTdt =', dSSTdt, 'Sea-Surface Temperature correction ',
     &                       'coefficient expressed',
     &            'kinematically as "piston velocity" [cm/day]'

          dSSTdt=dSSTdt/(100*day2sec)   !<-- Convert cm/day to convert to [m/s]
          ! This is also defined in put_global_atts so needs to be consistent.

# endif

#endif /* SOLVE3D */



#if  defined T_FRC_BRY || defined M2_FRC_BRY || defined TNUDGING \
  || defined Z_FRC_BRY || defined M3_FRC_BRY || defined M2NUDGING \
                       || defined M3NUDGING  || defined WKB_FRC_BRY

        elseif (keyword(1:kwlen) == 'ubind') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) ubind
            mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')
     &     'ubind =', ubind, 'open boundary binding velcity [m/s]'


/* OBSOLETE --->
! Parameters for OBC nudging and nudging layers;
! converted from [days] to [sec^-1]


c-->    elseif (keyword(1:kwlen) == 'nudg_cof') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) tauM2_in, tauM2_out, attnM2
# ifdef SOLVE3D
     &                       , tauM3_in, tauM3_out
     &                       , tauT_in,  tauT_out
# endif
          if (tauM2_in > 0.) then                ! convert relaxation
            tauM2_in =1./(tauM2_in *day2sec)     ! time [units = days]
          endif                                  ! into
          if (tauM2_out > 0.) then               ! nudging coefficient
            tauM2_out=1./(tauM2_out*day2sec)     ! [units = 1/sec]
          endif
# ifdef SOLVE3D
          if (tauM3_in > 0.) then
            tauM3_in =1./(tauM3_in *day2sec)
          endif
          if (tauM3_out > 0.) then
            tauM3_out=1./(tauM3_out*day2sec)
          endif
          if (tauT_in > 0.) then
            tauT_in =1./(tauT_in *day2sec)
          endif
          if (tauT_out > 0.) then
            tauT_out=1./(tauT_out*day2sec)
          endif
# endif
          mpi_master_only write(*,'(6x,A,ES10.3,ES10.3,2A)')
     &          'tauM2 =', tauM2_in, tauM2_out, '(in/out)  Nudging ',
     &                                   'for barotropic mode [s^-1]'
          mpi_master_only write(*,'(5x,A,ES10.3,2x,2A)') 'attnM2 =',
     &    attnM2,'open boundary pressure-gradient attenuation [s^-1]'
# ifdef SOLVE3D
          mpi_master_only write(*,'(6x,A,ES10.3,ES10.3,2A)')
     &          'tauM3 =', tauM3_in, tauM3_out, '(in/out)  Nudging ',
     &                                   'for baroclinic mode [s^-1]'
          mpi_master_only write(*,'(7x,A,ES10.3,ES10.3,2A)')
     &             'tauT =', tauT_in, tauT_out, '(in/out)  Nudging ',
     &                                          'for tracers [s^-1]'
# endif
           <--- OBSOLETE */
#endif


#ifdef SPONGE
! Parameters for the sponge layers

        elseif (keyword(1:kwlen) == 'v_sponge') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) v_sponge
          mpi_master_only write(*,'(3x,A,F10.2,2x,A)') 'v_sponge =',
     &        v_sponge, 'maximum viscosity in sponge layer [m^2/s]'
#endif

! Input file controls:  grid, initial conditions, surface forcing,
!----- ----- ---------  climatology, lateral boundary forcing data

#ifndef ANA_GRID
! Grid file name. Check its availability.

        elseif (keyword(1:kwlen) == 'grid') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) fname
#ifdef EXPANSE_TEST
          call expanse_scratch_env_var( fname )
#endif
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif
          open(testunit,file=fname(1:lstr), status='old', err=97)
          close(testunit)
          grdname=fname(1:lstr)
          mpi_master_only write(*,'(1x,2A)') 'grid file: ',
     &                                     grdname(1:lstr)
#endif

! Initial conditions file name. Check its availability (in the case
! of analytical initial conditions and nrrec=0 initial conditions are
! created internally and no file is needed).

        elseif (keyword(1:kwlen) == 'initial') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) nrrec
#ifdef ANA_INITIAL
          if (nrrec > 0) then
#endif
            read(input,'(A)',err=95) fname
#ifdef EXPANSE_TEST
            call expanse_scratch_env_var( fname )
#endif
            lstr=lenstr(fname)
#if defined MPI && defined PARALLEL_FILES
            call insert_node(fname, lstr, mynode, NNODES, ierr)
#endif
            ininame=fname(1:lstr)
            mpi_master_only write(*,'(1x,A,I3,2x,3A)')
     &       'initial condition :: rec =', nrrec,  'file = ''',
     &                                   ininame(1:lstr), ''''
#ifdef ANA_INITIAL
          endif
#endif
#if !defined ANA_SMFLUX  ||  defined SOLVE3D  &&\
   ( !defined ANA_STFLUX  ||\
     (defined SG_BBL96    && !defined ANA_BSEDIM) ||\
     (defined SG_BBL96    && !defined ANA_WWAVE)  ||\
     (defined QCORRECTION && !defined ANA_SST)    ||\
     (defined SALINITY    && !defined ANA_SSFLUX) ||\
     (defined LMD_KPP     && !defined ANA_SRFLUX))


! Forcing file name. Check its availability.

        elseif (keyword(1:kwlen) == 'forcing') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          max_frc=0
          lstr=1
          do while(lstr > 0 .and. max_frc < max_frc_files+1)
            read(input,'(A)',err=95) fname
            lstr=lenstr(fname)
            if (lstr > 0) then
#ifdef EXPANSE_TEST
              call expanse_scratch_env_var( fname )
              lstr=lenstr(fname)
#endif
# if defined MPI && defined PARALLEL_FILES
              call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif
              open(testunit,file=fname(1:lstr),status='old',err=97)
              close(testunit)

              if (max_frc < max_frc_files) then
                max_frc=max_frc+1
                frcfile(max_frc)=fname(1:lstr)
# ifdef MPI_SILENT_MODE
                if (mynode == 0) then
# endif
                  if (max_frc == 1) then
                    write(*,'(1x,2A)') 'forcing data file(s): ',
     &                                 frcfile(max_frc)(1:lstr)
                  else
                    write(*,'(23x,A)') frcfile(max_frc)(1:lstr)
                  endif

# ifdef MPI_SILENT_MODE
                endif
# endif
              else
                mpi_master_only write(*,'(1x,2A/12x,2A/)')
     &          '### ERROR: read_inp :: Too many forcing files are ',
     &          'specified in input script.',  'Increase parameter ',
     &                '''max_frc_files'' in ncvars.h and recompile.'
                ierr=ierr+1
              endif
            endif
          enddo
#endif

! Boundary forcing data file names. Check availability.

#if defined T_FRC_BRY || defined M2_FRC_BRY || defined M3_FRC_BRY \
                      || defined Z_FRC_BRY  || defined WKB_FRC_BRY
# ifndef ANA_BRY

        elseif (keyword(1:kwlen) == 'boundary') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          max_bry=0
          lstr=1
          do while(lstr > 0 .and. max_bry < max_bry_files+1)
            read(input,'(A)',err=95) fname
            lstr=lenstr(fname)
            if (lstr > 0) then
#  ifdef EXPANSE_TEST
              call expanse_scratch_env_var( fname )
              lstr=lenstr(fname)
#  endif
#  if defined MPI && defined PARALLEL_FILES
              call insert_node(fname, lstr, mynode, NNODES, ierr)
#  endif
              open(testunit, file=fname(1:lstr), status='old',err=97)
              close(testunit)

              if (max_bry < max_bry_files) then
                max_bry=max_bry+1
                bry_file(max_bry)=fname(1:lstr)
#  ifdef MPI_SILENT_MODE
                if (mynode == 0) then
#  endif
                  if (max_bry == 1) then
                    write(*,'(1x,2A)') 'boundary forcing file(s): ',
     &                                  bry_file(max_bry)(1:lstr)
                  else
                    write(*,'(27x,A)')  bry_file(max_bry)(1:lstr)

                  endif
#  ifdef MPI_SILENT_MODE
                endif
#  endif
              else
                mpi_master_only write(*,'(1x,2A/12x,2A/)')
     &         '### ERROR: read_inp :: Too many boundary files are ',
     &         'specified in input script.',   'Increase parameter ',
     &                '''max_bry_files'' in ncvars.h and recompile.'
                ierr=ierr+1
              endif
            endif
          enddo
# endif
#endif

! Climatology file name. Climatology data is needed for (1) to supply
! boundary data for T,S,u,v at open boundaries (just one row of points)
! and (2) nudging to T,S data inside the domain within the  nudging
! finite-width band near the boundary [although depreciated,  this
! practice  remains in some applications; doing so for u,v is no
! longer supported by this code].  Aternatively to (1), the boundary
! data may also be supplied via BRY mechanism, where file contains
! perimeter data only.  In this case (activated by T_FRC_BRY), no
! climatology file is needed.  The following code segments also
! checks for availability of clm_file.

#if defined SOLVE3D &&( defined TCLIMATOLOGY ||( defined TNUDGING && \
                        defined T_FRC_BRY )) && !defined ANA_TCLIMA

        elseif (keyword(1:kwlen) == 'climatology') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,'(A)',err=95) fname
          lstr=lenstr(fname)
# if defined MPI && defined PARALLEL_FILES
          call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif
          open(testunit, file=fname(1:lstr), status='old', err=97)
          close(testunit)
          clm_file=fname(1:lstr)
          mpi_master_only write(*,'(1x,4A)')   'climatology data :: ',
     &                           'file = ''', clm_file(1:lstr), ''''
#endif

! Output files controls: restart, history, averages, stations, floats
!------- ----- ---------

        elseif (keyword(1:kwlen) == 'restart') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) nrst, nrpfrst
          mpi_master_only write(*,'(1x,A,I8, 2x,A,I5)')
     &          'restart :: nrst =',nrst, 'rec/file =', nrpfrst
#ifndef SOLVE3D
          nrst=nrst*ndtfast
#endif

! history file controls: owerwrite flag, output frequency, number
! of reconds per file in sequence, and filename

        elseif (keyword(1:kwlen) == 'history') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) ldefhis, nwrt, nrpfhis
          mpi_master_only write(*,'(/1x,A,L1,2x,A,I5,2x,A,I4)')
     &       'history :: overwrite = ', ldefhis, 'nwrt =', nwrt,
     &       'rec/file =', nrpfhis
#ifndef SOLVE3D
          nwrt=nwrt*ndtfast
#endif

! Which fields to be saved into history file.

        elseif (keyword(1:kwlen) == 'primary_history_fields') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) wrthis(indxZ),  wrthis(indxUb)
     &                                      ,  wrthis(indxVb)
#ifdef SOLVE3D
     &                      ,  wrthis(indxU),  wrthis(indxV)
      ! DevinD: no longer use roms.in for tracer T/F inputs
!     &                      , (wrthis(indxT+itrc-1), itrc=1,NT)
#endif
          if ( wrthis(indxZ) .or. wrthis(indxUb) .or. wrthis(indxVb)
#ifdef SOLVE3D
     &                         .or. wrthis(indxU) .or. wrthis(indxV)
#endif
     &       ) wrthis(indxTime)=.true.

          mpi_master_only write(*,'(/1x,A,5(/8x,A,T16,L1,T20,A))')
     &                   'fields to write into history file: (T/F)'
     &                 , 'zeta',   wrthis(indxZ),    vname(2,indxZ)
     &                 , 'ubar',   wrthis(indxUb),   vname(2,indxUb)
     &                 , 'vbar',   wrthis(indxVb),   vname(2,indxVb)
#ifdef SOLVE3D
     &                 , 'u',      wrthis(indxU),    vname(2,indxU)
     &                 , 'v',      wrthis(indxV),    vname(2,indxV)
          do itrc=1,NT
            if (wrt_t(itrc)) wrthis(indxTime)=.true.
            mpi_master_only write(*,'(8x,A,I2,A,T16,L1,T20,A)') 't(',
     &        itrc, ')', wrt_t(itrc), t_vname(itrc)
          enddo

        elseif (keyword(1:kwlen) == 'auxiliary_history_fields') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) wrthis(indxR), wrthis(indxO)
     &          ,  wrthis(indxW),  wrthis(indxAkv),  wrthis(indxAkt)
# ifdef SALINITY
     &                                            ,  wrthis(indxAks)
# endif
# ifdef LMD_KPP
     &                                            ,  wrthis(indxHbls)
# endif
# ifdef LMD_BKPP
     &                                           ,  wrthis(indxHbbl)
# endif
          if ( wrthis(indxR) .or. wrthis(indxO) .or. wrthis(indxW)
     &                     .or. wrthis(indxAkv) .or. wrthis(indxAkt)
# ifdef SALINITY
     &                                          .or. wrthis(indxAks)
# endif
# ifdef LMD_KPP
     &                                          .or. wrthis(indxHbls)
# endif
# ifdef LMD_BKPP
     &                                          .or. wrthis(indxHbbl)
# endif
     &       ) wrthis(indxTime)=.true.


          mpi_master_only write(*,'(8(/8x,A,T16,L1,T20,A))')
     &                   'rho',    wrthis(indxR),    vname(2,indxR)
     &                 , 'Omega',  wrthis(indxO),    vname(2,indxO)
     &                 , 'W',      wrthis(indxW),    vname(2,indxW)
     &                 , 'Akv',    wrthis(indxAkv),  vname(2,indxAkv)
     &                 , 'Akt',    wrthis(indxAkt),  vname(2,indxAkt)
# ifdef SALINITY
     &                 , 'Aks',    wrthis(indxAks),  vname(2,indxAks)
# endif
# ifdef LMD_KPP
     &                 , 'hbls',   wrthis(indxHbls), vname(2,indxHbls)
# endif
# ifdef LMD_BKPP
     &                 , 'hbbl',   wrthis(indxHbbl), vname(2,indxHbbl)
# endif
#endif /* SOLVE3D */


#ifdef AVERAGES
! Averages controls: time step number to start averaging (sets phase
! for averaging windows); averaging interval in time steps; number of
! records per file, and output filename.

        elseif (keyword(1:kwlen) == 'averages') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) ntsavg, navg, nrpfavg
          mpi_master_only write(*,'(/1x,A,I5,2x,A,I5,2x,A,I4)')
     &       'averages :: ntsavg = ', ntsavg,      'navg =', navg,
     &       'rec/file =', nrpfavg
# ifndef SOLVE3D
          ntsavg=ntsavg*ndtfast ; navg=navg*ndtfast
# endif

! Switches for fields to compute averages.

        elseif (keyword(1:kwlen) == 'primary_averages') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtavg(indxZ),  wrtavg(indxUb)
     &                                        ,  wrtavg(indxVb)
# ifdef SOLVE3D
     &                      ,  wrtavg(indxU),     wrtavg(indxV)
      ! DevinD: no longer use roms.in for tracer T/F inputs
!     &                      , (wrtavg(indxT+itrc-1), itrc=1,NT)
# endif
          if ( wrtavg(indxZ) .or. wrtavg(indxUb) .or. wrtavg(indxVb)
# ifdef SOLVE3D
     &                       .or. wrtavg(indxU)  .or. wrtavg(indxV)
# endif
     &       ) wrtavg(indxTime)=.true.

          mpi_master_only write(*,'(/1x,A,5(/8x,A,T16,L1,T20,A))')
     &                   'fields to compute time averages of: (T/F)'
     &                 , 'zeta',   wrtavg(indxZ),    vname(2,indxZ)
     &                 , 'ubar',   wrtavg(indxUb),   vname(2,indxUb)
     &                 , 'vbar',   wrtavg(indxVb),   vname(2,indxVb)
# ifdef SOLVE3D
     &                 , 'u',      wrtavg(indxU),    vname(2,indxU)
     &                 , 'v',      wrtavg(indxV),    vname(2,indxV)
          do itrc=1,NT
            ! Currently have wrt_t(itrc) for primary_history fields. Need consistency.
            if (wrt_t_avg(itrc)) wrtavg(indxTime)=.true.
            mpi_master_only write(*,'(8x,A,I2,A,T16,L1,T20,A)') 't(',
     &        itrc, ')', wrt_t_avg(itrc), t_vname(itrc)
          enddo

        elseif (keyword(1:kwlen) == 'auxiliary_averages') then
          call cancel_kwd(keyword(1:kwlen), ierr)
          read(input,*,err=95) wrtavg(indxR), wrtavg(indxO)
     &          ,  wrtavg(indxW),  wrtavg(indxAkv),  wrtavg(indxAkt)
#  ifdef SALINITY
     &                                            ,  wrtavg(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                            ,  wrtavg(indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                                            ,  wrtavg(indxHbbl)
#  endif
          if ( wrtavg(indxR) .or. wrtavg(indxO) .or. wrtavg(indxW)
     &                     .or. wrtavg(indxAkv) .or. wrtavg(indxAkt)
#  ifdef SALINITY
     &                                          .or. wrtavg(indxAks)
#  endif
#  ifdef LMD_KPP
     &                                          .or. wrtavg(indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                                          .or. wrtavg(indxHbbl)
#  endif
     &       ) wrtavg(indxTime)=.true.

          mpi_master_only write(*,'(8(/8x,A,T16,L1,T20,A))')
     &                   'rho',    wrtavg(indxR),    vname(2,indxR)
     &                 , 'Omega',  wrtavg(indxO),    vname(2,indxO)
     &                 , 'W',      wrtavg(indxW),    vname(2,indxW)
     &                 , 'Akv',    wrtavg(indxAkv),  vname(2,indxAkv)
     &                 , 'Akt',    wrtavg(indxAkt),  vname(2,indxAkt)
#  ifdef SALINITY
     &                 , 'Aks',    wrtavg(indxAks),  vname(2,indxAks)
#  endif
#  ifdef LMD_KPP
     &                 , 'hbls',   wrtavg(indxHbls), vname(2,indxHbls)
#  endif
#  ifdef LMD_BKPP
     &                 , 'hbbl',   wrtavg(indxHbbl), vname(2,indxHbbl)
#  endif
# endif /* SOLVE3D */
#endif /* AVERAGES */

#ifdef WEC
      ! MRL wave-current interaction variables history fields
        elseif (keyword(1:kwlen).eq.'wci_history_fields') then
          call read_inp_wec(keyword, ierr, kwlen)
# ifdef AVERAGES
        elseif (keyword(1:kwlen).eq.'wci_average_fields') then
          call read_inp_avg_wec(keyword, ierr, kwlen)
# endif /* AVERAGES */
#endif /* WEC */

! Read output file root name using read_write.F module
        elseif (keyword(1:kwlen).eq.'output_root_name') then
          call read_output_root_name(keyword, kwlen)

        else
          mpi_master_only write(*,'(/1x,4A/)') 'WARNING: ',
     &                'Urecognized keyword ''', keyword(1:kwlen),
     &                                      ''' --> DISREGARDED.'
        endif
       if (keyword(1:kwlen) == end_signal) goto 99
      goto 1

! Error while reading input parameters.

  95  write(*,'(/1x,4A/)') '### ERROR: read_inp :: Cannot read ',
     &                       'entry ''', keyword(1:kwlen), '''.'
      ierr=ierr+1
      goto 99
  97  lstr=lenstr(fname)
      write(*,'(/1x,4A/)') '### ERROR: read_inp :: Cannot find ',
     &                     'input file ''', fname(1:lstr), '''.'
      ierr=ierr+1
  99  close (input)

! Check that all keywords were canceled, complain about the error,
! if some of them left.

      if (ierr == 0) call check_kwds (ierr)
      if (ierr /= 0) then
        write(*,'(/1x,2A,I3,1x,A/)') '### ERROR: read_inp :: ',
     &  'A total of', ierr, 'configuration errors discovered.'
       return
      endif
      call check_srcs
#ifdef MPI
      call MPI_Barrier (ocean_grid_comm, ierr)
#endif
      end

                                            ! Find place in the string
      subroutine cancel_kwd(keyword, ierr)  ! kwds(1:max_opt_size)
      implicit none                         ! which matches the input
#include "strings.h"
      character(len=*) keyword              ! keyword name and turn it
      integer ierr, is,i,ie, lenkw,lenstr   ! into blank. Complain
      lenkw=lenstr(keyword)                 ! about error if not found.
      is=1
      do while (is>0 .and. is<max_opt_size)
        do while (kwds(is:is)==' ' .and. is<max_opt_size)
          is=is+1
        enddo
        ie=is+1
        do while (kwds(ie:ie)/=' ' .and. ie<max_opt_size)
          ie=ie+1
        enddo
        if (lenkw==ie-is .and. kwds(is:ie-1)==keyword) then
c**       write(*,'(1x,A,1x,A)') 'Recognized: ', kwds(is:ie-1)
          do i=is,ie-1
            kwds(i:i)=' '
          enddo
          is=0         !--> to signal that keyword is found and
        else           !                      terminate the search
          is=ie        !--> skip to the next word in "kwds" string
        endif
      enddo
      if (is/=0) then
        write(*,'(/A)') '##### ERROR #####'
        write(*,'(2(1x,A,1x,A,1x,A/)/)') 'cancel_kwd:',
     &         'Can not cancel keyword:',  keyword(1:lenkw),
     &         'check input script for possible',
     &         'duplicated keywords.'
        write(*,'(A/)') '#################'
        ierr=ierr+1
      endif
      end

                                      ! Check that keyword string is
      subroutine check_kwds (ierr)    ! empty, and if it is not print
      implicit none                   ! out remaining keyword(s) as
#include "strings.h"
      integer ierr, is,ie             ! an error message and increase
      is=1                            ! error counter ierr.
      do while (is<max_opt_size)
        do while (kwds(is:is)==' ' .and. is<max_opt_size)
          is=is+1
        enddo
        if (is<max_opt_size) then
          ie=is+1
          do while (kwds(ie:ie)/=' ' .and. ie<max_opt_size)
            ie=ie+1
          enddo
          ierr=ierr+1
          write(*,'(/1x,A,1x,A/)') '### ERROR: keyword not found:',
     &                                               kwds(is:ie-1)
          is=ie
        endif
      enddo
      end


