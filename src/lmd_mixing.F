#include "cppdefs.opt"
      module lmd_mixing

      ! Parameterizations of vertical mixing based on:
      ! Large, W. G., J. C. McWilliams, and S. C. Doney, 1994:
      ! Oceanic vertical mixing: a review and a model
      ! with a nonlocal boundary layer parameterization,
      ! Rev. Geophys., 32, 363-403.

      use dimensions
      use roms_mpi

      use tracers
      use grid
      use mixing
      use ocean_vars
      use scalars
      use surf_flux
      use roms_read_write

#include "lmd_mixing.opt"

      logical,parameter :: lmd_mix = lmd_kpp.or.lmd_bkpp.or.lmd_rimix

      ! work space for smooth_2d
      real,allocatable,dimension(:,:) :: fx,fy,fx1,fy1

      public lmd_vmix

      contains

!---------------------------------------------------------
      subroutine init_lmd_mix ![

 
      if (mynode.eq.0) then
        print *,'Initializing lmd_mxing'
      endif

      allocate(fx(0:nx+1,0:ny+1))
      allocate(fy(0:nx+1,0:ny+1))
      allocate(fx1(0:nx+1,0:ny+1))
      allocate(fy1(0:nx+1,0:ny+1))

       if (mynode.eq.0) then
     !   print *, trim(lmd_mix_opt)
       endif

      lmd_mix_opt = ''
      if (lmd_rimix)  call store_string_att(lmd_mix_opt,'RIMIX, ')
      if (lmd_kpp)    call store_string_att(lmd_mix_opt,'KPP, ')
      if (lmd_bkpp)   call store_string_att(lmd_mix_opt,'BKPP, ')
      if (lmd_convec) call store_string_att(lmd_mix_opt,'CONVEC, ')
      if (lmd_nonloc) call store_string_att(lmd_mix_opt,'NONLOC, ')
      if (smooth_ri)  call store_string_att(lmd_mix_opt,'SMOOTH_RI ')
      
!     if (mynode.eq.0) then
     !  print *,'init lmd_vmix'
     !  print *, trim(lmd_mix_opt)
!     endif
        

      end subroutine init_lmd_mix !]
!---------------------------------------------------------
      subroutine lmd_vmix(tind) ![
!     Compute Akv and Akt; mixing coefficients for 
!     momenta and tracers.

      implicit none

      integer,intent(in)  :: tind

      ! Local
      integer  :: i,j,k
      real :: nu_sx, cff,cff1, dudz,dvdz
      real :: dist,mult
      real,dimension(:,:),allocatable :: Rig

!     integer  :: istr,iend,jstr,jend
 
      if (.not.allocated(fx)) then
        allocate(fx(0:nx+1,0:ny+1))
        allocate(fy(0:nx+1,0:ny+1))
        allocate(fx1(0:nx+1,0:ny+1))
        allocate(fy1(0:nx+1,0:ny+1))
      endif

!      istr = 1
!      jstr = 1
!      iend = nx
!      jend = ny


      if (lmd_rimix) then
        
        ! Could do this once in module init

        allocate(Rig(0:nx+1,0:ny+1))

!  Compute horizontal velocity shear (du/dz)^2+(dv/dz)^2 at
!  horizontal rho- and vertical w-points. Then compute gradient
!  Richardson number (already divided by its critical value.
!  Compute "interior" viscosities and diffusivities everywhere as
!  Richardson number instability due to resolved vertical shear
!  and internal wave breaking.

        do k=1,nz-1
          do j=0,ny+1
            do i=0,nx+1
              cff=0.5/(z_r(i,j,k+1)-z_r(i,j,k))
              dudz=cff*( u(i  ,j,k+1,tind)-u(i  ,j,k,tind)
     &                  +u(i+1,j,k+1,tind)-u(i+1,j,k,tind))
              dvdz=cff*( v(i,j  ,k+1,tind)-v(i,j  ,k,tind)
     &                  +v(i,j+1,k+1,tind)-v(i,j+1,k,tind))

              Rig(i,j) = bvf(i,j,k)/( Ri0*max(
     &                      dudz*dudz+dvdz*dvdz,1.e-10 ))
            enddo
          enddo

          ! We're using 4 2d arrays inside. Possibly pass work space or
          ! use pointers

          if (smooth_ri) call smooth_2d(Rig)

          do j=1,ny
            do i=1,nx

              cff=min(1., max(0., Rig(i,j)))
              nu_sx=1. - cff*cff
              nu_sx=nu_sx*nu_sx*nu_sx
              AKv(i,j,k)=nuwm + nu0m*nu_sx
              AKt(i,j,k)=nuws + nu0s*nu_sx

              if (lmd_convec.and.(Rig(i,j)<0.) ) then
                ! Mix tracers only
                AKt(i,j,k) = AKt(i,j,k) + nu0c
              endif
            enddo
          enddo
        enddo

      else  ! internal wave breaking only, 'background' mixing

        do k=1,nz-1
          do j=1,ny
            do i=1,nx
              AKv(i,j,k) = nuwm
              AKt(i,j,k) = nuws
            enddo
          enddo
        enddo
      endif

! Supress mixing away near the bottom.
      do k=1,nz-1
        do j=1,ny
          do i=1,nx
            dist = z_w(i,j,k)-z_w(i,j,0)
            if (dist<Lturb) then
              mult = sin(0.5*pi*(z_w(i,j,k) - z_w(i,j,0))/Lturb)
              AKv(i,j,k) = AKv(i,j,k)*mult
              AKt(i,j,k) = AKt(i,j,k)*mult
            endif
          enddo
        enddo
      enddo

      do j=1,ny
        do i=1,nx
          AKv(i,j,nz)=AKv(i,j,nz-1)
          AKt(i,j,nz)=AKt(i,j,nz-1)
          AKv(i,j,0 )=AKv(i,j,   1)
          AKt(i,j,0 )=AKt(i,j,   1)
        enddo
      enddo

      ! vertical smoothing of interior mixing
      do k=1,nz-1
        do j=1,ny
          do i=1,nx
            AKv(i,j,k)=0.5*AKv(i,j,k)+0.25*AKv(i,j,k-1)+0.25*AKv(i,j,k+1)
            AKt(i,j,k)=0.5*AKt(i,j,k)+0.25*AKt(i,j,k-1)+0.25*AKt(i,j,k+1)
          enddo
        enddo
      enddo

      ! Add surface and bottom boundary layer mixing
      if (lmd_kpp.or.lmd_bkpp) then
        call lmd_tbl(tind)
      endif

      !! Do we really need to exchange the mixing coefficients?
      call exchange_xxx(Akv,Akt)

      deallocate(Rig)

      end   subroutine lmd_vmix !]
!---------------------------------------------------------
      subroutine lmd_tbl(tind)   ![

# define INT_AT_RHO_POINTS
# define SMOOTH_HBL

      implicit none
      
      ! Local
      integer i,j,k
      real, dimension(1-bf:nx+bf,1-bf:ny+bf) :: ustar, Bo, Bosol
     &                                                  , hbl, bbl

      real, dimension(0:nx+1,0:nz) :: Cr,FC, wrk1,wrk2
      real, dimension(0:nx+1)    :: Bfsfc_bl
      integer, dimension(0:nx+1) :: kbls, kmo,kbbl
      integer :: tind

      real, parameter ::
      ! Ricr - chosen as 0.15 by JM & PD 2020-09
     &   Ricr=0.15,     ! Critical bulk Richardson number (0.3)
     &   Ri_inv=1./Ricr,
     &   epssfc=0.1,    ! nondimensional extent of the surface layer
     &   betaT=-0.2,    ! ratio of entrainment flux to surface buoyancy
                        !      forcing flux (the "20% convectin rule")
     &   nubl=0.01,     ! maximum allowed boundary layer
     &   nu0c=0.1,      ! convective adjustment for viscosity and
                        !                      diffusivity [m^2/s]
     &   Cv=1.8,        ! ratio of interior Brunt-Vaisala frequency
                        ! "N" to that at the entrainment depth "he".
     &   C_MO=1.,       ! constant for computaion Monin-Obukhov depth.
     &   C_Ek=258.,     ! constant for computating stabilization term
                        !    due to Coriolis force (Ekman depth limit)
     &   Cstar=10.,     ! proportionality coefficient parameterizing
                        !                         nonlocal transport
     &   zeta_m=-0.2,   ! Maximum stability parameters "zeta"
     &   a_m=1.257,     ! value of the 1/3 power law regime of
     &   c_m=8.360,     ! flux profile for momentum and tracers
     &   zeta_s=-1.0,   ! and coefficients of flux profile for
     &   a_s=-28.86,    ! momentum and tracers in their 1/3-power
     &   c_s=98.96      ! law regime;

      real,parameter :: r2=0.5, r3=1./3., r4=0.25, EPS=1.E-20

! Nondimensional constants for computing non-local flux and convective
! deepening of surface boundary layer. 
      real,parameter :: Cg = Cstar * vonKar * (c_s*vonKar*epssfc)**(1./3.)
      real,parameter :: Vtc= Cv * sqrt(-betaT/(c_s*epssfc)) / (Ricr*vonKar**2)


      real ustar3, Bfsfc, zscale, zetahat, ws,wm, Kern, Vtsq,
     &         ssgm, z_bl, cff,cff1, cff_up,cff_dn
!     real Cg, ustar3, Bfsfc, zscale, zetahat, ws,wm, Kern, Vtc,Vtsq,
!    &         ssgm, z_bl, cff,cff1, cff_up,cff_dn

      real Kv0, Kt0, Ks0, wmb,wsb, sgmb,amp
      integer  :: istr,iend,jstr,jend


! Compute thermal expansion, "alpha" [kg/m^3/degC], and saline
! contraction, "beta" [kg/m^3/PSU], coefficients at surface; then
! compute surface turbulent buoyancy forcing "Bo" [m^2/s^3] (in doing
! so remove incoming solar shortwave radiation component and save it
! separately as "Bosol"). Also get an approximation for the surface
! layer depth using "epssfc" and boundary layer depth from previous
! time step (this is needed to estimate turbulent velocity scale in
! computation of "Vterm" in "Cr", before new hbl is found).  Also
! compute turbulent  friction velocity "ustar" from wind stress at
! RHO-points. Initialize boundary layer depth "hbl" and index "kbls"
! to the maximum (bottomed out) values.

#  define alpha Bosol
#  define beta  Bo
      call alfabeta_tile (1,nx,1,ny,0,nx+1,0,ny+1,alpha,beta)

      ! JM if we move away from a virtual salt flux, this will have to 
      ! change: stflx(isalt) = - pme*sss
      do j=0,ny+1
        do i= 0,nx+1
          Bo(i,j)=g*( alpha(i,j)*(stflx(i,j,itemp)-srflx(i,j))
     &                              -beta(i,j)*stflx(i,j,isalt)
     &                                                        )
          Bosol(i,j)=g*alpha(i,j)*srflx(i,j)
#  undef beta
#  undef alpha

#   ifdef BULK_FRC
          ustar(i,j)=sqrt( sqrt( sustr_r(i,j)**2 +svstr_r(i,j)**2 ))
#   else
! Orginal for non-bulk-flux
          ustar(i,j)=sqrt( sqrt( 0.333333333333*(
     &      sustr(i,j)**2 + sustr(i+1,j)**2 + sustr(i,j)*sustr(i+1,j)
     &     +svstr(i,j)**2 + svstr(i,j+1)**2 + svstr(i,j)*svstr(i,j+1)
     &                                                            )))
#   endif /* BULK_FRC */

          hbl(i,j)=hbls(i,j)     ! use old-time-step values
          bbl(i,j)=hbbl(i,j)     ! as the initial guess

          kbls(i)=0
          Cr(i,nz)=0.
          Cr(i,0)=0.
          FC(i,nz)=0.
        enddo  !--> discard alpha,beta; keep Bo,Bosol to the very end.


        do k=nz-1,1,-1
          do i=0,nx+1
            cff_up=(z_w(i,j,N)-z_w(i,j,k))**2
            cff_dn=(z_w(i,j,k)-z_w(i,j,0))**2
            Kern=cff_up*cff_dn/( (cff_up +(epssfc*hbl(i,j))**2)
     &                          *(cff_dn +(epssfc*bbl(i,j))**2) )
            FC(i,k)=FC(i,k+1) + Kern*(
     &                0.5*( ( u(i,j,k+1,tind)+u(i+1,j,k+1,tind)
     &                       -u(i,j,k  ,tind)-u(i+1,j,k  ,tind) )**2
     &                     +( v(i,j,k+1,tind)+v(i,j+1,k+1,tind)
     &                       -v(i,j,k  ,tind)-v(i,j+1,k  ,tind) )**2
     &                      )/(Hz(i,j,k)+Hz(i,j,k+1))

     &               -0.5*(Hz(i,j,k)+Hz(i,j,k+1))*( Ri_inv*bvf(i,j,k)

     &                                            +C_Ek*f(i,j)*f(i,j)
     &                                                             ))
          enddo
        enddo


        do i = 0,nx+1
          z_bl=z_w(i,j,0)+0.25*Hz(i,j,1)
          cff_up=(z_w(i,j,N)-z_bl)**2
          cff_dn=(z_bl-z_w(i,j,0))**2
          Kern=cff_up*cff_dn/( (cff_up +(epssfc*hbl(i,j))**2)
     &                        *(cff_dn +(epssfc*bbl(i,j))**2) )
            FC(i,0)=FC(i,1) + Kern*(
     &                   0.5*( (u(i,j,1,tind)+u(i+1,j,1,tind))**2
     &                        +(v(i,j,1,tind)+v(i,j+1,1,tind))**2
     &                       )/Hz(i,j,1)
     &                  -0.5*Hz(i,j,1)*( Ri_inv*bvf(i,j,1)
     &                                  +C_Ek*f(i,j)*f(i,j)
     &                                                       ))
        enddo

#   define swdk_r wrk1
        ! Surface kpp boundary layer
        do k = nz,1,-1
          do i = 0,nx+1
            swdk_r(i,k)=sqrt(swr_frac(i,j,k)*swr_frac(i,j,k-1))

            zscale=z_w(i,j,N)-z_r(i,j,k)
            Bfsfc=Bo(i,j)+Bosol(i,j)*(1.-swdk_r(i,k))

#   include "lmd_wscale_ws_only.h"

c--         Vtsq=Vtc*ws*sqrt(max(0., 0.5*(bvf(i,j,k)+bvf(i,j,k-1)) ))

            Vtsq=Vtc*ws*sqrt(max(0., bvf(i,j,k-1) ))  !<-- fix by Gokhan

            Cr(i,k)=FC(i,k)+Vtsq

            if (kbls(i) == 0 .and. Cr(i,k) < 0.) kbls(i)=k
          enddo
        enddo

        do i = 0,nx+1
          if (kbls(i) > 0) then
            k=kbls(i)
            if (k == nz) then
              hbl(i,j)=z_w(i,j,nz)-z_r(i,j,nz)
            else
              hbl(i,j)=z_w(i,j,nz)-( z_r(i,j,k)*Cr(i,k+1)
     &                              -z_r(i,j,k+1)*Cr(i,k)
     &                              )/(Cr(i,k+1)-Cr(i,k))
            endif
          else
            hbl(i,j)=z_w(i,j,nz)-z_w(i,j,0)
          endif
          hbl(i,j)=hbl(i,j)*rmask(i,j) ! is this needed?
        enddo
#   undef swdk_r

        ! Bottom kpp boundary layer
        do i= 0,nx+1
          kbbl(i)=0       ! reset Cr at bottom and kbls for BKPP
          Cr(i,0)=0.D0
        enddo
        do k=1,nz
          do i = 0,nx+1
            Cr(i,k)=FC(i,k)-FC(i,0)
            if (kbbl(i) == 0 .and. Cr(i,k) > 0.) kbbl(i)=k
          enddo
        enddo
        do i = 0,nx+1
          if (kbbl(i) > 0) then
            k=kbbl(i)
            if (k == 1) then
              bbl(i,j)=z_r(i,j,1)-z_w(i,j,0)   ! no BBL
            else
              bbl(i,j)=( z_r(i,j,k-1)*Cr(i,k)-z_r(i,j,k)*Cr(i,k-1)
     &                            )/(Cr(i,k)-Cr(i,k-1)) -z_w(i,j,0)
            endif
          else
            bbl(i,j)=z_w(i,j,nz)-z_w(i,j,0) ! total depth
          endif
          bbl(i,j)=bbl(i,j)*rmask(i,j)
        enddo     !--> discard FC, Cr and kbbl

      enddo  ! j-loop 

      if (lmd_kpp)  call smooth_2d(hbl)
      if (lmd_bkpp) call smooth_2d(bbl)

      do j=1,ny

        if (.not. FIRST_TIME_STEP) then
          ! 'time' averaging
          if (lmd_kpp)  hbl(1:nx,j)=0.5*(hbl(1:nx,j)+hbls(1:nx,j))
          if (lmd_bkpp) bbl(1:nx,j)=0.5*(bbl(1:nx,j)+hbbl(1:nx,j))
        endif 

        ! Surface boundary layer

        do i=1,nx
          kbls(i)=nz         ! initialize search, then find
        enddo                ! new boundary layer index "kbls"
        do k=nz-1,1,-1
          do i= 1,nx
            if (z_w(i,j,k) > z_w(i,j,nz)-hbl(i,j)) kbls(i)=k
          enddo
        enddo

!       do i=1,nx
!         msk = z_w(i,j,:) > z_w(i,j,nz)-hbl(i,j)
!         kbls(i) = findloc(z_w(i,j,:),.true.,msk)
!       enddo

! Find buoyancy forcing for final "hbl" values, and compute turbulent
! velocity scales (wm,ws) at "hbl".  Then compute nondimensional shape
! function coefficients Gx( ) by matching values and vertical
! derivatives of  interior mixing coefficients at hbl (ssgm=1).

        do i = 1,nx
          k=kbls(i)
          z_bl = z_w(i,j,nz)-hbl(i,j)
          zscale=hbl(i,j)

          if (swr_frac(i,j,k-1) > 0.) then
            Bfsfc=Bo(i,j) +Bosol(i,j)*( 1. -swr_frac(i,j,k-1)
     &              *swr_frac(i,j,k)*(z_w(i,j,k)-z_w(i,j,k-1))
     &               /( swr_frac(i,j,k  )*(z_w(i,j,k)   -z_bl)
     &                 +swr_frac(i,j,k-1)*(z_bl -z_w(i,j,k-1))
     &                                                     ) )
          else
            Bfsfc=Bo(i,j)+Bosol(i,j)
          endif

#  include "lmd_wscale_wm_and_ws.h"

          Bfsfc_bl(i)=Bfsfc
        enddo

! Compute boundary layer mixing coefficients.
!--------- -------- ----- ------ -------------
! Compute turbulent velocity scales at vertical W-points.

        do i=istr,iend
          do k=N,0,-1
            Bfsfc=Bfsfc_bl(i)
            zscale=z_w(i,j,N)-z_w(i,j,k)

#  include "lmd_wscale_wm_and_ws.h"

! Compute vertical mixing coefficients

            ! boundary layer coordinate [0,1]
            ssgm=(z_w(i,j,nz)-z_w(i,j,k))/max(hbl(i,j),EPS)

            if (ssgm < 1.) then
              ! add a little non-zero tail to the mixing near
              ! the surface
              if (ssgm<0.07D0) then
                cff=0.5*(ssgm-0.07D0)**2/0.07D0
              else
                cff=0.0
              endif
              cff=cff + ssgm*(1.-ssgm)**2

              ! amp scales away the 'background' or Ri mixing related Kv to 
              ! zero near the surface. It's the equivalent of mult below for
              ! the bottom boundary layer
              amp = ssgm**2
              AKv(i,j,k)=sqrt((amp*AKv(i,j,k))**2 + (wm*hbl(i,j)*cff)**2 )
              AKt(i,j,k)=sqrt((amp*AKt(i,j,k))**2 + (ws*hbl(i,j)*cff)**2 )


#  ifdef LMD_NONLOCAL
              if (Bfsfc < 0.) then
                ghat(i,j,k)=Cg * ssgm*(1.-ssgm)**2
              else
                ghat(i,j,k)=0.
              endif
#  endif
            else
#  ifdef LMD_NONLOCAL
              ghat(i,j,k)=0.
#  endif
            endif
          enddo
        enddo

        do i=istr,iend
          kbbl(i) = nz       !<-- initialize search
        enddo
        do k=N-1,1,-1       ! find new boundary layer index "kbls"
          do i=istr,iend
            if (z_w(i,j,k) > z_w(i,j,0)+bbl(i,j)) kbbl(i)=k
          enddo
        enddo

! Compute nondimensional shape function coefficients Gx( ) by matching
! values and vertical derivatives of interior mixing coefficients at
! bbl (sgmb=1).  Below wm,ws are turbulent velocity scales associated
! with bottom drag, assuming no buoyancy forcing effects.


        do i=istr,iend
          ! wmb = vonKar*ustar_bottom (rd*u)
          wmb=vonKar*vonKar*sqrt( 0.333333333333*(
     &               u(i,j,1,nstp)**2 +u(i+1,j,1,nstp)**2
     &                      +u(i,j,1,nstp)*u(i+1,j,1,nstp)
     &              +v(i,j,1,nstp)**2 +v(i,j+1,1,nstp)**2
     &                      +v(i,j,1,nstp)*v(i,j+1,1,nstp)
     &                                               ) )
     &                  / log(1.+0.5*Hz(i,j,1)/Zob)

          wsb=wmb

! Compute boundary layer mixing coefficients.
!--------- -------- ----- ------ -------------
! Compute turbulent velocity scales at vertical W-points.

          do k=0,nz
            sgmb=(z_w(i,j,k)-z_w(i,j,0)+Zob)/(bbl(i,j)+Zob)
            if (sgmb < 1.) then

              cff1=sgmb*(1.-sgmb)**2

              AKv(i,j,k)=sqrt( AKv(i,j,k)**2 + (wmb*bbl(i,j)*cff1)**2 )
              AKt(i,j,k)=sqrt( AKt(i,j,k)**2 + (wsb*bbl(i,j)*cff1)**2 )

            endif
          enddo      !<-- k
        enddo      !<-- i


        do i=istr,iend
# ifdef MASKING
          if (rmask(i,j) > 0.5) then
# endif
            if (FIRST_TIME_STEP) then
            else
# ifdef WEC
              do k=1,N      ! Apply wave effects
                Akv(i,j,k) = Akv(i,j,k)+Akb(i,j,k)
                Akt(i,j,k) = Akt(i,j,k)+Akb(i,j,k)+Akw(i,j,k)
              enddo
              Akv(i,j,0) = 2.*Akv(i,j,1)-Akv(i,j,2)
              Akt(i,j,0) = 2.*Akt(i,j,1)-Akt(i,j,2,itemp)
# endif

            endif  !<-- FIRST_TIME_STEP
# ifdef MASKING
          else
            do k=0,nz
              Akv(i,j,k)=0.
              Akt(i,j,k)=0.
            enddo
          endif
# endif
        enddo
      enddo ! j-loop

# ifdef LMD_KPP
      do j=jstr,jend                   ! Copy "hbl" into shared array
        do i=istr,iend                 ! and padd lateral ghost points
          hbls(i,j)=hbl(i,j)
        enddo
      enddo
#  ifndef EW_PERIODIC
      if (WESTERN_EDGE) then
        do j=jstr,jend
          hbls(istr-1,j)=hbls(istr,j)
        enddo
      endif
      if (EASTERN_EDGE) then
        do j=jstr,jend
          hbls(iend+1,j)=hbls(iend,j)
        enddo
      endif
#  endif
#  ifndef NS_PERIODIC
      if (SOUTHERN_EDGE) then
        do i=istr,iend
          hbls(i,jstr-1)=hbls(i,jstr)
        enddo
      endif
      if (NORTHERN_EDGE) then
        do i=istr,iend
          hbls(i,jend+1)=hbls(i,jend)
        enddo
      endif
#   ifndef EW_PERIODIC
      if (WESTERN_EDGE .and. SOUTHERN_EDGE) then
        hbls(istr-1,jstr-1)=hbls(istr,jstr)
      endif
      if (WESTERN_EDGE .and. NORTHERN_EDGE) then
        hbls(istr-1,jend+1)=hbls(istr,jend)
      endif
      if (EASTERN_EDGE .and. SOUTHERN_EDGE) then
        hbls(iend+1,jstr-1)=hbls(iend,jstr)
      endif
      if (EASTERN_EDGE .and. NORTHERN_EDGE) then
        hbls(iend+1,jend+1)=hbls(iend,jend)
      endif
#   endif
#  endif
# endif   /* LMD_KPP */
# ifdef LMD_BKPP
      do j=jstr,jend                   ! Copy "bbl" into shared array
        do i=istr,iend                 ! and padd lateral ghost points
          hbbl(i,j)=bbl(i,j)
        enddo
      enddo
#  ifndef EW_PERIODIC
      if (WESTERN_EDGE) then
        do j=jstr,jend
          hbbl(istr-1,j)=hbbl(istr,j)
        enddo
      endif
      if (EASTERN_EDGE) then
        do j=jstr,jend
          hbbl(iend+1,j)=hbbl(iend,j)
        enddo
      endif
#  endif
#  ifndef NS_PERIODIC
      if (SOUTHERN_EDGE) then
        do i=istr,iend
          hbbl(i,jstr-1)=hbbl(i,jstr)
        enddo
      endif
      if (NORTHERN_EDGE) then
        do i=istr,iend
          hbbl(i,jend+1)=hbbl(i,jend)
        enddo
      endif
#   ifndef EW_PERIODIC
      if (WESTERN_EDGE .and. SOUTHERN_EDGE) then
        hbbl(istr-1,jstr-1)=hbbl(istr,jstr)
      endif
      if (WESTERN_EDGE .and. NORTHERN_EDGE) then
        hbbl(istr-1,jend+1)=hbbl(istr,jend)
      endif
      if (EASTERN_EDGE .and. SOUTHERN_EDGE) then
        hbbl(iend+1,jstr-1)=hbbl(iend,jstr)
      endif
      if (EASTERN_EDGE .and. NORTHERN_EDGE) then
        hbbl(iend+1,jend+1)=hbbl(iend,jend)
      endif
#   endif
#  endif
# endif   /* LMD_KPP */

# ifdef EXCHANGE
#  ifdef LMD_KPP
#   ifdef LMD_BKPP
      call exchange_xxx(Akv)
      call exchange_xxx(hbls)
      call exchange_xxx(hbbl)
#   else
      call exchange_xxx(Akv)
      call exchange_xxx(hbls)
#   endif
#  else
      call exchange_xxx(Akv)
      call exchange_xxx(hbbl)
#  endif
      call exchange_xxx(Akt)
# endif
      end subroutine lmd_tbl !]
!---------------------------------------------------------
      subroutine smooth_2d(f) ![

! Smooth function in 2 dimensions ![
! Apply horizontal smoothing operator to a private array "wrk" (which
! is actually a CPP-alias for "hbl" or "hbbl").  The array is computed
! within a tile with one row of extra points all-around except lateral
! physical boundaries. The smoothed field is computed over the internal
! range of indices within the tile and is placed back to the same array
! "wrk".  The smoothing is performed while avoiding values under land
! mask which is accomplished by expressing everything via elementary
! differences subject to masking by U- and V-rules (hence applying
! Neumann condition at the coastline).  Without masking the stencil of
! the smoothing operator has the following weights, depending on
! coefficient settings in the code segment below:
!
!   cff=0, cff1=1/8        cff=1/12, cff1=3/16        cff=1/8, cff1=1/4
!
!         1/8                1/32  1/8  1/32           1/16  1/8  1/16
!
!    1/8  1/2  1/8           1/8   3/8  1/8            1/8   1/4  1/8
!
!         1/8                1/32  1/8  1/32           1/16  1/8  1/16
!
!       5-point                 isotropic                 2D 1-2-1
!      Laplacian                Laplacian                 Hanning
!
! All three smoothing operators suppress the checkerboard mode in just
! after a single iteration, however, only the last one eliminates flat-
! front 2dx-modes in one iteration; the first and the second attenuate
! the 2dx-mode by factors of 1/2 and 1/4 per iteration.   !]

      implicit none

      real,dimension(0:nx+1,0:ny+1),intent(inout) :: f
      real,parameter ::cff = 1.0/12.0 
      real,parameter ::cff1= 3.0/16.0

      ! Local
      integer :: i,j


      if (.not.ew_periodic) then
        if (inode.eq.0) then
          f(0,0:ny+1) = f(1,0:ny+1)
        endif
        if (inode.eq.npx-1) then
          f(nx+1,0:ny+1) = f(nx,0:ny+1)
        endif
      endif
      if (.not.ns_periodic) then
        if (jnode.eq.0) then
          f(0:nx+1,0) = f(0:nx+1,1)
        endif
        if (jnode.eq.npy-1) then
          f(0:nx+1,ny+1) = f(0:nx+1,ny)
        endif
      endif 

     ! Isotropic smoothing by first computing masked           
     ! elementary differences in each direction,
     ! after which expressing the transversal terms
     ! via the very same masked differences.

      do j=0,ny+1
        do i=1,nx+1
          fx1(i,j)=(f(i,j)-f(i-1,j))*umask(i,j)
        enddo
      enddo
      do j=1,ny+1
        do i=0,nx+1
          fy1(i,j)=(f(i,j)-f(i,j-1))*vmask(i,j)
        enddo
      enddo
      do j=1,ny
        do i=1,nx+1
          fx(i,j)=fx1(i,j) + cff*( fy1(i,j+1)+fy1(i-1,j  )
     &                            -fy1(i,j  )-fy1(i-1,j+1))
        enddo
      enddo
      do j=1,ny+1
        do i=1,nx
          fy(i,j)=fy1(i,j) + cff*( fx1(i+1,j)+fx1(i  ,j-1)
     &                            -fx1(i  ,j)-fx1(i+1,j-1))
        enddo
      enddo
      do j=1,ny
        do i=1,nx
          f(i,j) = f(i,j) + cff1*( fx(i+1,j)-fx(i,j)
     &                            +fy(i,j+1)-fy(i,j))
        enddo
      enddo 

      end subroutine smooth_2d  !]
!---------------------------------------------------------

      end module lmd_mixing
